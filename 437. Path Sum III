// 使用recursive來做遍歷每個點算出sum
// 但每次遍歷的時候都需要另外在把child node當作主節點再另外做recursive
// 但這種方式會導致child node被重複當作parent node遍歷
// 所以create一個set來記錄那些child node已經被當作parent node遍歷了

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    
    void find_sum(TreeNode* node, int sum, int count, int &res, unordered_set<TreeNode*> &s){
        
        if(node == nullptr)
            return;
        
        count += node->val; // count + 現再node的值
        
        if(count == sum) // 如果count == sum, path++
            res++;
        
        find_sum(node->left, sum, count, res, s); // 繼續往下累加count
        find_sum(node->right, sum, count, res, s); // 繼續往下累加count
        
        if(s.count(node->left) == 0) // 避免對child node重複當作parent node 做recursive，所以如果set 裡面有紀錄表示這個child node已經被當作parent node 做recursive了
        {
            s.insert(node->left); // 紀錄子節點已經被當作root，避免重複做
            find_sum(node->left, sum, 0, res, s); // 把子節點當作root往下重新累加count
        }
        
        if(s.count(node->right) == 0) // 避免對child node重複當作parent node 做recursive，所以如果set 裡面有紀錄表示這個child node已經被當作parent node 做recursive了
        {
            s.insert(node->right); // 紀錄子節點已經被當作root，避免重複做
            find_sum(node->right, sum, 0, res, s);// 把子節點當作root往下重新累加count
        }
        
    }
    
    int pathSum(TreeNode* root, int sum) {
        
        int res = 0;
        unordered_set<TreeNode*> s; // create the set to record which child node is as a parent node in recursion
        
        s.insert(root);
        find_sum(root, sum, 0, res, s);
        return res;
        
        
        
        
    }
};
